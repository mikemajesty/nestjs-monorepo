"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkConfig = exports.doesReadmeHashExist = exports.doesCoverageHashesExist = exports.doesCoverageFileExist = exports.doesReadmeFileExistWithRightPermissions = void 0;
const fs_1 = __importDefault(require("fs"));
const constants_1 = require("./constants");
const helpers_1 = require("./helpers");
const logger_1 = require("./logger");
const { logInfo } = (0, logger_1.logger)();
const doesReadmeFileExistWithRightPermissions = (readmePath) => {
    return new Promise((resolve, reject) => {
        try {
            // NOTE: Doing this check for the accessibility before reading/writing it
            //       is not recommended as it introduces racing conditions since other
            //       processes may change the file's state between the two call.
            //       But for simplicity and considering the context of this library,
            //       this wrong access file handling is toleralable.
            fs_1.default.accessSync((0, helpers_1.getReadmePath)(readmePath), fs_1.default.constants.R_OK | fs_1.default.constants.W_OK);
            return resolve(true);
        }
        catch (err) {
            if ((0, helpers_1.isNodeErrnoError)(err)) {
                if (err.code === 'ENOENT')
                    return reject('Readme file does not exist');
                if (err.code === 'EACCES')
                    return reject('Readme file does not have read and write permissions');
                return reject(err.message);
            }
            return reject(err.message || 'Something went wrong');
        }
    });
};
exports.doesReadmeFileExistWithRightPermissions = doesReadmeFileExistWithRightPermissions;
const doesCoverageFileExist = (coveragePath) => {
    return new Promise((resolve, reject) => {
        const currentCoveragePath = (0, helpers_1.getCoveragePath)(coveragePath);
        const doesItExist = fs_1.default.existsSync(currentCoveragePath);
        if (doesItExist)
            return resolve(true);
        return reject(`Coverage file does not exist in ${currentCoveragePath}`);
    });
};
exports.doesCoverageFileExist = doesCoverageFileExist;
const doesCoverageHashesExist = (coveragePath) => {
    return new Promise((resolve, reject) => {
        const coverageFile = fs_1.default.readFileSync((0, helpers_1.getCoveragePath)(coveragePath));
        constants_1.hashesConst.coverage.forEach((hash) => {
            if (coverageFile.includes(hash.key))
                resolve(true);
        });
        return reject('Coverage file does contain the needed hashes');
    });
};
exports.doesCoverageHashesExist = doesCoverageHashesExist;
const doesReadmeHashExist = (readmePath) => {
    return new Promise((resolve, reject) => {
        const readmeFile = fs_1.default.readFileSync((0, helpers_1.getReadmePath)(readmePath));
        constants_1.hashesConst.coverage.forEach((hash) => {
            if (readmeFile.includes(`![${hash.value}]`))
                resolve(true);
        });
        return reject('Readme does not contain the needed hashes');
    });
};
exports.doesReadmeHashExist = doesReadmeHashExist;
const checkConfig = () => {
    logInfo('Config check process started');
    return (0, exports.doesReadmeFileExistWithRightPermissions)(constants_1.readmePathConst)
        .then(() => {
        logInfo('- Readme file exists... ✔️.');
    })
        .then(() => (0, exports.doesCoverageFileExist)(constants_1.coveragePathConst))
        .then(() => {
        logInfo('- Coverage file exists... ✔️.');
    })
        .then(() => (0, exports.doesCoverageHashesExist)(constants_1.coveragePathConst))
        .then(() => {
        logInfo('- Coverage hashes exist... ✔️.');
    })
        .then(() => (0, exports.doesReadmeHashExist)(constants_1.readmePathConst))
        .then(() => {
        logInfo('- Readme hashes exist... ✔️.');
    })
        .then(() => logInfo('Config check process ended'));
};
exports.checkConfig = checkConfig;
//# sourceMappingURL=validate.js.map