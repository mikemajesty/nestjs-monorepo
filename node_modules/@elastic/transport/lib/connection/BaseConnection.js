"use strict";
/*
 * Licensed to Elasticsearch B.V. under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch B.V. licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", { value: true });
exports.getIssuerCertificate = exports.prepareHeaders = void 0;
const tslib_1 = require("tslib");
const util_1 = require("util");
const Diagnostic_1 = tslib_1.__importDefault(require("../Diagnostic"));
const errors_1 = require("../errors");
const symbols_1 = require("../symbols");
class BaseConnection {
    constructor(opts) {
        var _d, _e, _f, _g, _h, _j;
        Object.defineProperty(this, "url", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tls", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "timeout", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "headers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "deadCount", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "resurrectTimeout", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_openRequests", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "weight", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _b, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _c, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.url = opts.url;
        this.tls = (_d = opts.tls) !== null && _d !== void 0 ? _d : null;
        this.id = (_e = opts.id) !== null && _e !== void 0 ? _e : stripAuth(opts.url.href);
        this.headers = prepareHeaders(opts.headers, opts.auth);
        this.timeout = (_f = opts.timeout) !== null && _f !== void 0 ? _f : 30000;
        this.deadCount = 0;
        this.resurrectTimeout = 0;
        this.weight = 0;
        this._openRequests = 0;
        this[symbols_1.kStatus] = (_g = opts.status) !== null && _g !== void 0 ? _g : BaseConnection.statuses.ALIVE;
        this[symbols_1.kDiagnostic] = (_h = opts.diagnostic) !== null && _h !== void 0 ? _h : new Diagnostic_1.default();
        this[symbols_1.kCaFingerprint] = (_j = opts.caFingerprint) !== null && _j !== void 0 ? _j : null;
        if (!['http:', 'https:'].includes(this.url.protocol)) {
            throw new errors_1.ConfigurationError(`Invalid protocol: '${this.url.protocol}'`);
        }
    }
    get status() {
        return this[symbols_1.kStatus];
    }
    set status(status) {
        if (!validStatuses.includes(status)) {
            throw new errors_1.ConfigurationError(`Unsupported status: '${status}'`);
        }
        this[symbols_1.kStatus] = status;
    }
    get diagnostic() {
        return this[symbols_1.kDiagnostic];
    }
    async request(params, options) {
        throw new errors_1.ConfigurationError('The request method should be implemented by extended classes');
    }
    /* istanbul ignore next */
    async close() {
        throw new errors_1.ConfigurationError('The close method should be implemented by extended classes');
    }
    // Handles console.log and utils.inspect invocations.
    // We want to hide `auth`, `agent` and `tls` since they made
    // the logs very hard to read. The user can still
    // access them with `instance.agent` and `instance.tls`.
    [(_a = symbols_1.kStatus, _b = symbols_1.kCaFingerprint, _c = symbols_1.kDiagnostic, util_1.inspect.custom)](depth, options) {
        const { authorization, ...headers } = this.headers;
        return {
            url: stripAuth(this.url.toString()),
            id: this.id,
            headers,
            status: this.status
        };
    }
    toJSON() {
        const { authorization, ...headers } = this.headers;
        return {
            url: stripAuth(this.url.toString()),
            id: this.id,
            headers,
            status: this.status
        };
    }
}
exports.default = BaseConnection;
Object.defineProperty(BaseConnection, "statuses", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: {
        ALIVE: 'alive',
        DEAD: 'dead'
    }
});
const validStatuses = Object.keys(BaseConnection.statuses)
    // @ts-expect-error
    .map(k => BaseConnection.statuses[k]);
function stripAuth(url) {
    if (!url.includes('@'))
        return url;
    return url.slice(0, url.indexOf('//') + 2) + url.slice(url.indexOf('@') + 1);
}
function prepareHeaders(headers = {}, auth) {
    if (auth != null && headers.authorization == null) {
        /* istanbul ignore else */
        if (isApiKeyAuth(auth)) {
            if (typeof auth.apiKey === 'object') {
                headers.authorization = 'ApiKey ' + Buffer.from(`${auth.apiKey.id}:${auth.apiKey.api_key}`).toString('base64');
            }
            else {
                headers.authorization = `ApiKey ${auth.apiKey}`;
            }
        }
        else if (isBearerAuth(auth)) {
            headers.authorization = `Bearer ${auth.bearer}`;
        }
        else if (auth.username != null && auth.password != null) {
            headers.authorization = 'Basic ' + Buffer.from(`${auth.username}:${auth.password}`).toString('base64');
        }
    }
    return headers;
}
exports.prepareHeaders = prepareHeaders;
function isApiKeyAuth(auth) {
    return auth.apiKey != null;
}
function isBearerAuth(auth) {
    return auth.bearer != null;
}
function getIssuerCertificate(socket) {
    let certificate = socket.getPeerCertificate(true);
    while (certificate !== null && Object.keys(certificate).length > 0) {
        // invalid certificate
        if (certificate.issuerCertificate == null) {
            return null;
        }
        // We have reached the root certificate.
        // In case of self-signed certificates, `issuerCertificate` may be a circular reference.
        if (certificate.fingerprint256 === certificate.issuerCertificate.fingerprint256) {
            break;
        }
        // continue the loop
        certificate = certificate.issuerCertificate;
    }
    return certificate;
}
exports.getIssuerCertificate = getIssuerCertificate;
//# sourceMappingURL=BaseConnection.js.map